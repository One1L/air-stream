/** * reinit можно отправлять несолкьо раз, и он теперь не обновляет очередь, * для полного обновления нужно сделать полный реистанс модели * * filter не заботится о сохранности reinit для инициализации потока * * сохранность $SID должна гарантироваться извне */export default class Observable {    constructor(emitter) {        this.obs = [];        this.emitter = emitter;        this.queue = [];    }    on(obs) {        if(!this.obs.length) {            const emt = (evt, src) => this.emit(evt, src);            emt.emit = emt;            emt.complete = (evt, src) => this.complete(evt, src);            this._disconnect = this.emitter(emt) || null;        }        this.obs.push(obs);        this.queue && this.queue.forEach( evt =>            this.pushToQueue({act: () => obs( ...evt ), __sid__: evt[1].__sid__}) );        return () => {            this.obs.splice(this.obs.indexOf(obs), 1);            !this.obs.length && this._disconnect && this._disconnect();        }    }    emit(data, { __sid__ = Observable.__sid__ ++, type = this.queue.length  ? "change" : "reinit"} = {}) {        !this.queue.length && (type = "reinit");        const evt = [data, {__sid__, type}];        type === "reinit" && (this.queue.length = 0);        this.queue.push(evt);        this.obs.forEach( obs => this.pushToQueue({act: () => obs( ...evt ), __sid__}) );    }    complete(data, { __sid__ = Observable.__sid__ ++, type = "complete"} = {}) {        const evt = [data, {__sid__, type}];        this.queue.push(evt);        this.obs.forEach( obs => this.pushToQueue({act: () => obs( ...evt ), __sid__}) );    }    /**     * todo need refactor     * @param act     * @param sid     */    pushToQueue({act, __sid__}) {        if(!Observable.queue) {            Observable.queue = [];            let queue = Observable.queue;            const pop = () => {                Observable.dirtqueue && queue.sort(({__sid__: a}, {__sid__: b}) => a - b);                Observable.dirtqueue = false;                queue.shift().act();                if (queue.length) pop();                else Observable.queue = null;            };            setImmediate(pop);        }        Observable.queue.push({act, __sid__});        Observable.dirtqueue = true;    }    /**     * 1 - новое событие от инициатора     *     * 2 - новое событие от ведомого     * @param observables     * @param project     * @return Observable     */    withLatestFrom(observables = [], project = (...args) => args) {        return new Observable( emt => {            const off = [];            function check(evt, src) {                const mess = observables.map(obs => {                    const last = obs.queue.length && obs.queue.slice(-1)[0];                    return last && last.__sid__ <= src.__sid__ ? last : null                });                if(mess.every(msg => msg)) {                    emt({...project(evt, ...mess)}, src);                }            }            //если изменение из пассивов            observables.forEach( obs => off.push(obs.on( evt => {                //только если стволовой поток инициализирован                //и текущий поток еще не был задействован                if(this.queue.length && obs.queue.length === 1) {                    check(...this.queue.slice(-1)[0]);                }            })) );            //если изменение от источника событий            off.push(this.on( check ));            return () => off.forEach( unobserve => unobserve() );        } );    }    static combine(observables = [], project = (...args) => args) {        return new Observable( emt => {            const off = observables.map( obs => obs.on( (evt, src) => {                let events = observables                    .map( ({ queue }) => queue.filter( ([_, {__sid__}]) => __sid__ <= src.__sid__ ) );                if(events.every( evt => !!evt.length )) {                    events = events.map( evt => evt.slice(-1)[0][0] );                    events.splice( observables.indexOf(obs), 1, evt );                    emt( project(...events), src );                }            } ) );            return () => off.forEach(unobserve => unobserve());        });    }    withHandler( handler ) {        return new Observable( emt =>            this.on( (evt, src) => {                const _emt = evt => emt(evt, src);                _emt.emit = _emt;                return handler(_emt, evt)            })        );    }    cut( project ) {        return this.withHandler( (emt, evt) => {            const data = project(evt);            data && emt(data)        } );    }    /**     * @param project     * @return Observable     */    partially(project) {        return this.withHandler( (emt, evt) => emt({...evt, ...project(evt)}) );    }    /**     * @param project     * @return Observable     */    map( project ) {        return this.withHandler( (emt, evt) => emt(project(evt)) );    }    /**     *     * @param project     * @return Observable     */    filter( project ) {        return this.withHandler( (emt, evt) => project(evt) && emt(evt) );    }    log() {        this.on( (evt, src) => console.log(evt, src));    }}Observable.__sid__ = 0;