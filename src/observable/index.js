/** * reinit можно отправлять несолкьо раз, и он теперь не обновляет очередь, * для полного обновления нужно сделать полный реистанс модели * * filter не заботится о сохранности reinit для инициализации потока * * сохранность $SID должна гарантироваться извне */const keyF = { keyF: "keyF" };const empty = { empty: "empty" };export default class Observable {    constructor(emitter) {        this.obs = [];        this.emitter = emitter;        this.queue = [];        this.processed = [];        this.init = false;    }    on(obs) {        if(!this.obs.length) {            const emt = (evt, src) => this.emit(evt, src);            emt.emit = emt;            emt.emt = emt;            emt.kf = () => this.emit(keyF);            this._disconnect = this.emitter(emt) || null;        }        this.queue.map( evt => obs(...evt) );        this.obs.push(obs);        return ( { dissolve = false, ... args } = { dissolve: true } ) => {            if(dissolve) {                this.obs.splice(this.obs.indexOf(obs), 1);                if(!this.obs.length) {                    this.init = false;                    this.queue = [];                    this.processed.map( process => {                        this.cutFromQueue(process);                    } );                    this.processed = [];                }                if(this._disconnect) {                    !this.obs.length && (Array.isArray(this._disconnect) ?                        this._disconnect.map( dis => dis( ) ) : this._disconnect( ));                }            }            else {                Array.isArray(this._disconnect) ?                    this._disconnect.map( dis => dis( args ) ) : this._disconnect( args );            }        }    }    emit(data, { __sid__ = Observable.__sid__ ++ } = {}) {        /*<DEBUG TODO>*/        if(!this.init && data !== keyF) {            throw new `attempt to emit without connect`;        }        /*</DEBUG>*/        this.init = true;        /*<DEBUG TODO>*/        if(data === undefined) throw `attempt to emit 'undefined' data`;        //if(data.hasOwnProperty("name") && data.name === undefined) throw data;        /*</DEBUG>*/        if(data === keyF) {            this.processed.map( process => {                this.cutFromQueue(process);            } );        }        const evt = [data, {__sid__ }];        const process = {act: () => {            this.obs.map(obs => obs( ...evt ));            if(data === keyF) this.queue.length = 0;            this.queue.push(evt);            this.processed.splice( this.processed.indexOf(evt), 1 );        }, __sid__};        this.processed.push(process);        this.pushToQueue(process);    }    static merge(observables = []) {        return new Observable( emt => {            const tails = observables.map( obs => obs.on( emt ) );            return (...args) => tails.map(tail => tail(...args));        });    }    cutFromQueue(process) {        const {queue} = Observable;        queue.splice(queue.indexOf(process), 1);    }    /**     * todo need refactor     * @param act     * @param sid     */    pushToQueue({act, __sid__}) {        if(!Observable.queue) {            Observable.queue = [];            const queue = Observable.queue;            const pop = () => {                Observable.dirtqueue && queue.sort(                    ({__sid__: a, idx: ax}, {__sid__: b, idx: bx}) => a !== b ? a - b : ax - bx                );                Observable.dirtqueue = false;                queue.shift().act();                if (queue.length) pop();                else {                    Observable.queue = null;                    Observable.idx = 0;                }            };            setImmediate(pop);        }        Observable.queue.push({act, __sid__, idx: Observable.idx++});        Observable.dirtqueue = true;    }    /**     * 1 - новое событие от инициатора     *     * 2 - новое событие от ведомого     * @param observables     * @param project     * @return Observable     */    withLatestFrom(observables = [], project = (...args) => args) {        return new Observable( emt => {            const tails = [];            function check(evt, src) {                const mess = observables.map(obs => {                    const last = obs.queue.length && obs.queue.slice(-1)[0];                    return last && last.__sid__ <= src.__sid__ ? last : null                });                if(mess.every(msg => msg)) {                    emt({...project(evt, ...mess)}, src);                }            }            //если изменение из пассивов            observables.forEach( obs => tails.push(obs.on( evt => {                //только если стволовой поток инициализирован                //и текущий поток еще не был задействован                if(this.queue.length && obs.queue.length === 1) {                    check(...this.queue.slice(-1)[0]);                }            })) );            //если изменение от источника событий            tails.push(this.on( check ));            return (...args) => tails.map( tail => tail(...args) );        } );    }    first() {        return new Observable( emt => this.on( (evt, src) => src.type === "reinit" && emt(evt, src) ) );    }    reducer(initer, project) {        return new Observable( emt => {            let subs = ()=>{};            const subs2 = initer.on( _evt => {                let acc = _evt;                subs();                subs = this.on( (evt, src) => {                    if(evt === keyF) {                        emt( evt, src );                    }                    if(evt === keyF && _evt !== keyF) {                        acc = _evt;                        emt( acc, src );                    }                    if( _evt !== keyF && evt !== keyF ) {                        emt( acc = project(acc, evt, src), src );                    }                } );            } );            return ( {dissolve, ...args} ) => {                dissolve && subs2 && subs2();                subs && subs({ dissolve, ...args });            }        } );    }    switcher(observables) {        return new Observable( emt => {            let current = null;            const sub = this.on( state => {                current();                current = observables[state].on( emt );            } );            return (...args) => {                current && current(...args);                sub && sub(...args);            }        } );    }    reduce(project) {        return new Observable( emt => {            let acc = empty;            return this.on( (evt, src) => {                if(evt === keyF) {                    acc = empty;                    emt(evt, src);                }                else if(acc === empty) {                    acc = evt;                    emt(acc, src);                }                else {                    emt(acc = project( acc, evt, src ), src);                }            } );        } );    }    $reduce( project ) {        return new Observable( emt => {            const history = [];            return this.on( (evt, src) => {                const reducer = new Observable( (emt) => {                    if(evt === keyF) {                        if(src.is.ok) {                            //подтверждение                            const {rid} = src;                        }                        else if(src.is.err) {                            //отмена                            const {rid} = src;                        }                        else {                        }                    }                } )                    .reduce()                    .on();                const subs = this.reduce( project ).on( ( evt, src ) => {                    if(evt === keyF) {                        history.push( evt );                    }                    else {                        history.length = 0;                    }                });            } );        } )            .reduce( project );    }    mergeMap( project ) {        return new Observable( (emt) => {            const subs = [ this.on((evt, src) => {                subs[1] && subs[1]();                subs[1] = project(evt).on(() => emt(evt, src));            }) ];            return (...args) => subs.map( x => x(...args) )        });    }    static combine(observables = [], project = (...args) => args) {        if(!observables.length) throw `observables must be an array of length at least 1`;        return new Observable( emt => {            const tails = observables.map( obs => obs.on( (evt, src) => {                let events = observables                    .map( ({ queue }) => queue.filter( ([_, {__sid__}]) => __sid__ <= src.__sid__ ) );                if(events.every( evt => !!evt.length )) {                    events = events.map( evt => evt.slice(-1)[0][0] );                    events.splice( observables.indexOf(obs), 1, evt );                    emt( project(...events), src );                }            } ) );            return (...args) => tails.forEach(tail => tail(...args));        });    }    withHandler( handler ) {        return new Observable( emt =>            this.on( (evt, src) => {                if(evt === keyF) return emt( evt, src );                const _emt = evt => emt(evt, src);                _emt.emit = _emt;                return handler(_emt, evt)            })        );    }    cut( project ) {        return this.withHandler( (emt, evt) => {            const data = project(evt);            data && emt(data)        } );    }    /**     * @param project     * @return Observable     */    partially(project) {        return this.withHandler( (emt, evt) => emt({...evt, ...project(evt)}) );    }    /**     * @param project     * @return Observable     */    map( project ) {        return this.withHandler( (emt, evt) => emt(project(evt)) );    }    /**     *     * @param project     * @return Observable     */    filter( project ) {        return this.withHandler( (emt, evt) => project(evt) && emt(evt) );    }    log( label = "" ) {        this.on( (evt, src) => console.log(label, evt, src));    }}Observable.__sid__ = 0;Observable.keyF = keyF;