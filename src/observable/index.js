/** * reinit можно отправлять несолкьо раз, и он теперь не обновляет очередь, * для полного обновления нужно сделать полный реистанс модели * * filter не заботится о сохранности reinit для инициализации потока * * сохранность $SID должна гарантироваться извне */const keyF = { keyF: "keyF" };export default class Observable {    constructor(emitter, queue = []) {        this.obs = [];        this.emitter = emitter;        this.queue = queue;    }    on(obs, {temporary = false} = {}) {        if(!this.obs.length) {            const emt = (evt, src) => this.emit(evt, src);            emt.emit = emt;            emt.emt = emt;            emt.kf = () => this.emit(keyF);            this.queue.map( evt => obs(...evt) );            this._disconnect = this.emitter(emt) || null;        }        else if(this.queue.length && !temporary) {            return new Observable( emt => this.on(emt, {temporary: true}), this.queue ).on(obs);        }        this.obs.push(obs);        //кроме того нужно забирать те сообщения из очереди, которые еще в списке на выполнение        //и если обработчик добавляется в тот момент когда сообщений нет, то, значит, что он успел        //далее, в идеале, нужно "смесить" временный поток с основным        /*this.queue.forEach( evt =>            this.pushToQueue({ act: () => obs( ...evt ), __sid__: evt[1].__sid__}) );*/        return ( { dissolve = false, ... args } = { dissolve: true } ) => {            if(this._disconnect) {                if(dissolve) {                    this.obs.splice(this.obs.indexOf(obs), 1);                    !this.obs.length && (Array.isArray(this._disconnect) ?                        this._disconnect.map( dis => dis( ) ) : this._disconnect( ));                }                else {                    Array.isArray(this._disconnect) ?                        this._disconnect.map( dis => dis( args ) ) : this._disconnect( args );                }            }        }    }    emit(data, {        __sid__ = Observable.__sid__ ++,        type = this.queue.length  ? "change" : "reinit",    } = {}) {        /*<DEBUG TODO>*/        if(data === undefined) throw `attempt to emit 'undefined' data`;        //if(data.hasOwnProperty("name") && data.name === undefined) throw data;        /*</DEBUG>*/        if(data === keyF) {            this.queue.length = 0;        }        !this.queue.length && (type = "reinit");        const evt = [data, {__sid__, type }];        type === "reinit" && (this.queue.length = 0);        this.queue.push(evt);        this.pushToQueue({act: () => this.obs.map(obs => obs( ...evt )), __sid__});        //this.obs.forEach( obs => this.pushToQueue({act: () => obs( ...evt ), __sid__}) );    }    static merge(observables = []) {        return new Observable( emt => {            const tails = observables.map( obs => obs.on( emt ) );            return (...args) => tails.map(tail => tail(...args));        });    }    /**     * todo need refactor     * @param act     * @param sid     */    pushToQueue({act, __sid__}) {        if(!Observable.queue) {            Observable.queue = [];            let queue = Observable.queue;            const pop = () => {                Observable.dirtqueue && queue.sort(                    ({__sid__: a, idx: ax}, {__sid__: b, idx: bx}) => a !== b ? a - b : ax - bx                );                Observable.dirtqueue = false;                queue.shift().act();                if (queue.length) pop();                else {                    Observable.queue = null;                    Observable.idx = 0;                }            };            setImmediate(pop);        }        Observable.queue.push({act, __sid__, idx: Observable.idx++});        Observable.dirtqueue = true;    }    /**     * 1 - новое событие от инициатора     *     * 2 - новое событие от ведомого     * @param observables     * @param project     * @return Observable     */    withLatestFrom(observables = [], project = (...args) => args) {        return new Observable( emt => {            const tails = [];            function check(evt, src) {                const mess = observables.map(obs => {                    const last = obs.queue.length && obs.queue.slice(-1)[0];                    return last && last.__sid__ <= src.__sid__ ? last : null                });                if(mess.every(msg => msg)) {                    emt({...project(evt, ...mess)}, src);                }            }            //если изменение из пассивов            observables.forEach( obs => tails.push(obs.on( evt => {                //только если стволовой поток инициализирован                //и текущий поток еще не был задействован                if(this.queue.length && obs.queue.length === 1) {                    check(...this.queue.slice(-1)[0]);                }            })) );            //если изменение от источника событий            tails.push(this.on( check ));            return (...args) => tails.map( tail => tail(...args) );        } );    }    first() {        return new Observable( emt => this.on( (evt, src) => src.type === "reinit" && emt(evt, src) ) );    }    reducer(initer, project) {        return new Observable( emt => {            let subs = null;            const subs2 = initer.on( _evt => {                let acc;                if(subs) {                    subs();                    subs = null;                }                if(_evt !== keyF) {                    acc = _evt;                    subs = this.on( (evt, src) => {                        if( evt !== keyF ) {                            emt( acc = project(acc, evt, src), src );                        }                        else {                            emt( evt, src );                            acc = _evt;                            emt( acc, src );                        }                    } );                }            } );            return ( {dissolve, ...args} ) => {                dissolve && subs2 && subs2();                subs && subs({ dissolve, ...args });            }        } );    }    switcher(observables) {        return new Observable( emt => {            let current = null;            const sub = this.on( state => {                current();                current = observables[state].on( emt );            } );            return (...args) => {                current && current(...args);                sub && sub(...args);            }        } );    }    mergeMap( project ) {        return new Observable( (emt) => {            const subs = [ this.on((evt, src) => {                subs[1] && subs[1]();                subs[1] = project(evt).on(() => emt(evt, src));            }) ];            return (...args) => subs.map( x => x(...args) )        });    }    static combine(observables = [], project = (...args) => args) {        if(!observables.length) throw `observables must be an array of length at least 1`;        return new Observable( emt => {            const tails = observables.map( obs => obs.on( (evt, src) => {                let events = observables                    .map( ({ queue }) => queue.filter( ([_, {__sid__}]) => __sid__ <= src.__sid__ ) );                if(events.every( evt => !!evt.length )) {                    events = events.map( evt => evt.slice(-1)[0][0] );                    events.splice( observables.indexOf(obs), 1, evt );                    emt( project(...events), src );                }            } ) );            return (...args) => tails.forEach(tail => tail(...args));        });    }    withHandler( handler ) {        return new Observable( emt =>            this.on( (evt, src) => {                if(evt === keyF) return emt( evt, src );                const _emt = evt => emt(evt, src);                _emt.emit = _emt;                return handler(_emt, evt)            })        );    }    cut( project ) {        return this.withHandler( (emt, evt) => {            const data = project(evt);            data && emt(data)        } );    }    /**     * @param project     * @return Observable     */    partially(project) {        return this.withHandler( (emt, evt) => emt({...evt, ...project(evt)}) );    }    /**     * @param project     * @return Observable     */    map( project ) {        return this.withHandler( (emt, evt) => emt(project(evt)) );    }    /**     *     * @param project     * @return Observable     */    filter( project ) {        return this.withHandler( (emt, evt) => project(evt) && emt(evt) );    }    log() {        this.on( (evt, src) => console.log(evt, src));    }}Observable.__sid__ = 0;Observable.keyF = keyF;