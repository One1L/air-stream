/** * reinit можно отправлять несолкьо раз, и он теперь не обновляет очередь, * для полного обновления нужно сделать полный реистанс модели * * filter не заботится о сохранности reinit для инициализации потока * * сохранность $SID должна гарантироваться извне */export default class Observable {    constructor(emitter) {        this.obs = [];        this.emitter = emitter;        this.queue = [];    }    on(obs) {        if(!this.obs.length) {            const emt = (evt, src) => this.emit(evt, src);            emt.emit = emt;            emt.complete = (evt, src) => this.complete(evt, src);            this._disconnect = this.emitter(emt) || null;        }        this.obs.push(obs);        this.queue && this.queue.forEach( evt =>            this.pushToQueue({act: () => obs( ...evt ), __sid__: evt[1].__sid__}) );        return ( { dissolve = false, ... args } = { dissolve: true } ) => {            if(this._disconnect) {                if(dissolve) {                    this.obs.splice(this.obs.indexOf(obs), 1);                    !this.obs.length && (Array.isArray(this._disconnect) ?                        this._disconnect.map( dis => dis( ) ) : this._disconnect( ));                }                else {                    Array.isArray(this._disconnect) ?                        this._disconnect.map( dis => dis( args ) ) : this._disconnect( args );                }            }        }    }    emit(data, { __sid__ = Observable.__sid__ ++, type = this.queue.length  ? "change" : "reinit"} = {}) {        /*<DEBUG TODO>*/        if(data === undefined) throw data;        //if(data.hasOwnProperty("name") && data.name === undefined) throw data;        /*</DEBUG>*/        !this.queue.length && (type = "reinit");        const evt = [data, {__sid__, type}];        type === "reinit" && (this.queue.length = 0);        this.queue.push(evt);        this.obs.forEach( obs => this.pushToQueue({act: () => obs( ...evt ), __sid__}) );    }    complete(data, { __sid__ = Observable.__sid__ ++, type = "complete"} = {}) {        const evt = [data, {__sid__, type}];        this.queue.push(evt);        this.obs.forEach( obs => this.pushToQueue({act: () => obs( ...evt ), __sid__}) );    }    static merge(observables = []) {        return new Observable( emt => {            const tails = observables.map( obs => obs.on( emt ) );            return (...args) => tails.map(tail => tail(...args));        });    }    /**     * todo need refactor     * @param act     * @param sid     */    pushToQueue({act, __sid__}) {        if(!Observable.queue) {            Observable.queue = [];            let queue = Observable.queue;            const pop = () => {                Observable.dirtqueue && queue.sort(({__sid__: a}, {__sid__: b}) => a - b);                Observable.dirtqueue = false;                queue.shift().act();                if (queue.length) pop();                else Observable.queue = null;            };            setImmediate(pop);        }        Observable.queue.push({act, __sid__});        Observable.dirtqueue = true;    }    /**     * 1 - новое событие от инициатора     *     * 2 - новое событие от ведомого     * @param observables     * @param project     * @return Observable     */    withLatestFrom(observables = [], project = (...args) => args) {        return new Observable( emt => {            const tails = [];            function check(evt, src) {                const mess = observables.map(obs => {                    const last = obs.queue.length && obs.queue.slice(-1)[0];                    return last && last.__sid__ <= src.__sid__ ? last : null                });                if(mess.every(msg => msg)) {                    emt({...project(evt, ...mess)}, src);                }            }            //если изменение из пассивов            observables.forEach( obs => tails.push(obs.on( evt => {                //только если стволовой поток инициализирован                //и текущий поток еще не был задействован                if(this.queue.length && obs.queue.length === 1) {                    check(...this.queue.slice(-1)[0]);                }            })) );            //если изменение от источника событий            tails.push(this.on( check ));            return (...args) => tails.map( tail => tail(...args) );        } );    }    first() {        return new Observable( emt =>            this.on( (evt, src) => src.type === "reinit" && emt(evt, src) )        );    }    switcher(observables) {        return new Observable( emt => {            let current = null;            const sub = this.on( state => {                current();                current = observables[state].on( emt );            } );            return (...args) => {                current && current(...args);                sub && sub(...args);            }        } );    }    mergeMap( project ) {        return new Observable( (emt) => {            const subs = [ this.on((evt, src) => {                subs[1] && subs[1]();                subs[1] = project(evt).on(() => emt(evt, src));            }) ];            return (...args) => subs.map( x => x(...args) )        });    }    static combine(observables = [], project = (...args) => args) {        if(!observables.length) throw `observables must be an array of length at least 1`;        return new Observable( emt => {            const tails = observables.map( obs => obs.on( (evt, src) => {                let events = observables                    .map( ({ queue }) => queue.filter( ([_, {__sid__}]) => __sid__ <= src.__sid__ ) );                if(events.every( evt => !!evt.length )) {                    events = events.map( evt => evt.slice(-1)[0][0] );                    events.splice( observables.indexOf(obs), 1, evt );                    emt( project(...events), src );                }            } ) );            return (...args) => tails.forEach(tail => tail(...args));        });    }    withHandler( handler ) {        return new Observable( emt =>            this.on( (evt, src) => {                const _emt = evt => emt(evt, src);                _emt.emit = _emt;                return handler(_emt, evt)            })        );    }    cut( project ) {        return this.withHandler( (emt, evt) => {            const data = project(evt);            data && emt(data)        } );    }    /**     * @param project     * @return Observable     */    partially(project) {        return this.withHandler( (emt, evt) => emt({...evt, ...project(evt)}) );    }    /**     * @param project     * @return Observable     */    map( project ) {        return this.withHandler( (emt, evt) => emt(project(evt)) );    }    /**     *     * @param project     * @return Observable     */    filter( project ) {        return this.withHandler( (emt, evt) => project(evt) && emt(evt) );    }    log() {        this.on( (evt, src) => console.log(evt, src));    }}Observable.__sid__ = 0;